<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Depth Lockscreen Demo</title>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<style>
body, html { margin:0; height:100%; overflow:hidden; background:#000; font-family:sans-serif; }
#wallpaperImg, #depthCanvas, #fgCanvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
#ui { position:absolute; inset:0; z-index:5; display:flex; flex-direction:column; align-items:center; padding-top:80px; color:white; pointer-events:none; }
#time { font-size:84px; font-weight:200; text-shadow:0 10px 40px rgba(0,0,0,.6); }
#date { opacity:0.8; margin-top:-10px; }
</style>
</head>
<body>

<img id="wallpaperImg" src="https://images.unsplash.com/photo-1507525428034-b723cf961d3e?w=1080" crossorigin="anonymous">

<canvas id="depthCanvas"></canvas>
<canvas id="fgCanvas"></canvas>

<div id="ui">
  <div id="time">10:45</div>
  <div id="date">Monday, Jan 1</div>
</div>

<script>
const depthCanvas = document.getElementById('depthCanvas');
const fgCanvas = document.getElementById('fgCanvas');
const dctx = depthCanvas.getContext('2d');
const fctx = fgCanvas.getContext('2d');

let session;
async function loadModel(){
  session = await ort.InferenceSession.create(
    "https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx",
    { executionProviders:['wasm'] }
  );
  console.log("Model ready", session.inputNames, session.outputNames);
}
loadModel();

// Clock
function updateClock() {
  const d = new Date();
  document.getElementById('time').textContent =
    `${d.getHours() % 12 || 12}:${String(d.getMinutes()).padStart(2,'0')}`;
  document.getElementById('date').textContent =
    d.toLocaleDateString(undefined,{ weekday:'long', month:'short', day:'numeric' });
}
setInterval(updateClock,1000);
updateClock();

const img = document.getElementById('wallpaperImg');
img.onload = async () => {
  if(!session) return console.warn("Model not ready");

  const modelW = 384;
  const modelH = 384;
  const tmp = document.createElement('canvas');
  tmp.width = modelW;
  tmp.height = modelH;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(img,0,0,modelW,modelH);
  const imData = tctx.getImageData(0,0,modelW,modelH).data;

  // RGB to Float32
  const input = new Float32Array(modelW*modelH*3);
  for(let i=0;i<modelW*modelH;i++){
    input[i*3+0] = imData[i*4+0]/255;
    input[i*3+1] = imData[i*4+1]/255;
    input[i*3+2] = imData[i*4+2]/255;
  }
  const tensor = new ort.Tensor('float32', input, [1,3,modelH,modelW]);
  const feeds = {}; feeds[session.inputNames[0]] = tensor;

  const output = await session.run(feeds);
  let depthData = output[session.outputNames[0]].data;

  // Normalize depth to [0,255]
  let min=Infinity,max=-Infinity;
  for(const v of depthData){ if(v<min)min=v; if(v>max)max=v; }
  depthData = depthData.map(v=>255*(v-min)/(max-min));

  // Draw depth as grayscale
  depthCanvas.width = fgCanvas.width = img.width;
  depthCanvas.height = fgCanvas.height = img.height;
  const outImg = dctx.createImageData(modelW,modelH);
  for(let i=0;i<depthData.length;i++){
    const v = depthData[i];
    outImg.data[i*4+0]=v;
    outImg.data[i*4+1]=v;
    outImg.data[i*4+2]=v;
    outImg.data[i*4+3]=255;
  }

  const bitmap = await createImageBitmap(outImg);
  dctx.clearRect(0,0,depthCanvas.width,depthCanvas.height);
  dctx.drawImage(bitmap,0,0,depthCanvas.width,depthCanvas.height);

  // Apply depth mask to foreground canvas
  fctx.clearRect(0,0,fgCanvas.width,fgCanvas.height);
  fctx.drawImage(img,0,0,fgCanvas.width,fgCanvas.height);
  const fg = fctx.getImageData(0,0,fgCanvas.width,fgCanvas.height);
  for(let i=0;i<fg.data.length;i+=4){
    const depthIdx = Math.floor((i/4)*(depthData.length)/(fg.data.length/4));
    if(depthData[depthIdx] < 100) fg.data[i+3]=0; // background
  }
  fctx.putImageData(fg,0,0);
}
</script>

</body>
</html>
